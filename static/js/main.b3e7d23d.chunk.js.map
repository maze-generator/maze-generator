{"version":3,"sources":["classes/cell.ts","classes/compass.ts","classes/maze.ts","helpers/shuffle.ts","classes/unicode-graphic.ts","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["Cell","compass","position","pathways","neighbors","this","directions","direction","undefined","Object","values","includes","boundaries","that","reversed","reverse","entries","isPath","Compass","dimensions","_dimensions","_magnitudes","_magnets","opposites","magnitudes","multiplier","a","b","keys","forEach","_","index","push","slice","reduce","Set","offset","rose","modifier","vectors","map","set","Map","vector","get","tetragonSlicer","coordinates","size","allCells","Array","validCells","cellIndex","isValid","currentPosition","positionIndex","currentDimension","magnitude","Math","floor","TetragonCompass","x","y","coordinate","triangulator","Maze","generate","index1","index2","validIndex","coordinates1","coordinates2","differences","coordinate1","currentCell","array","items","length","random","results","i","roll","splice","shuffle","neighborCell","neighborIndex","validNeighbors","joinWithNeighbor","pathWithNeighbor","UnicodeGraphic","maze","result","cell","north","south","east","west","getGlyph","type","pipe","edge","myMaze","myGraphic","Graphic","console","log","App","useState","pipeMaze","words","setWords","onClick","newMaze","newGraphic","value","className","readOnly","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"4QAEqBA,E,WAKpB,WACCC,EACAC,GACE,yBAPIA,cAOL,OANKC,cAML,OALKC,eAKL,OAJeH,aAIf,EAEDI,KAAKH,SAAWA,EAChBG,KAAKJ,QAAUA,EAGfI,KAAKF,SAAW,GAChBE,KAAKD,UAAY,GAPhB,2BAQD,YAAwBC,KAAKJ,QAAQK,WAArC,+CAAiD,CAAC,IAAvCC,EAAsC,QAChDF,KAAKF,SAASI,IAAa,EAC3BF,KAAKD,UAAUG,QAAaC,GAV5B,mF,sDA4BD,OAAOC,OAAOC,OAAOL,KAAKF,UAAUQ,UAAS,K,gCAQ7C,OAAOF,OAAOC,OAAOL,KAAKO,YAAYD,UAAS,K,sCAM/CE,GAGA,OAAOJ,OAAOC,OAAOL,KAAKD,WAAWO,SAASE,K,uCAM9CA,EACAN,GAIA,IAAMO,EAAkBT,KAAKJ,QAAQc,QAAQR,GAE7CF,KAAKD,UAAUG,GAAaM,EAC5BA,EAAKT,UAAUU,GAAYT,O,uCAI3BQ,EACAN,GAIA,IAAMO,EAAkBT,KAAKJ,QAAQc,QAAQR,GAE7CF,KAAKF,SAASI,IAAa,EAC3BM,EAAKV,SAASW,IAAY,I,iCArD1B,IAFA,IAAMF,EAAoC,GAE1C,MAAkCH,OAAOO,QAAQX,KAAKF,UAAtD,eAAiE,CAAC,IAAD,sBAArDI,EAAqD,KAA1CU,EAA0C,KAChEL,EAAWL,IAAcU,EAG1B,OAAOL,M,0BChCYM,E,WAMpB,WACCC,GACE,yBAPgBC,iBAOjB,OANiBC,iBAMjB,OALQC,cAKR,OAJKC,eAIL,OAHKjB,gBAGL,EAED,IAAMkB,EAA2B,GAC3BC,EAAa,SAACC,EAAUC,GAAX,OAA+BD,EAAIC,GAEtDlB,OAAOmB,KAAKT,GAAYU,SAAQ,SAC/BC,EACAC,GAEAP,EAAWQ,KACVb,EAAWc,MAAM,EAAGF,GAAOG,OAAOT,EAAY,OAGhDpB,KAAKe,YAAcD,EACnBd,KAAKgB,YAAcG,EACnBnB,KAAKiB,SAAW,GAChBjB,KAAKkB,UAAY,GACjBlB,KAAKC,WAAa,IAAI6B,I,oDA6CR5B,GAGd,OAAOF,KAAKkB,UAAUhB,K,6BAItBwB,GAGA,IADA,IAAMK,EAA+B,GACrC,MAAoC3B,OAAOO,QAAQX,KAAKgC,MAAxD,eAA+D,CAAC,IAAD,sBAAnD9B,EAAmD,KAAxC+B,EAAwC,KAC9DF,EAAO7B,GAAawB,EAAQO,EAE7B,OAAOF,I,2BAtDP,OAAO/B,KAAKiB,U,aAIZe,GAIAhC,KAAKC,WAAa,IAAI6B,IAAI1B,OAAOmB,KAAKS,IAOtC,IAQME,EAEL9B,OAAOmB,KAAKS,GAAMH,QAVH,SACfM,EACAjC,GAIA,OADAiC,EAAIC,IAAIJ,EAAK9B,GAAYA,GAClBiC,IAI2B,IAAIE,KAGvCrC,KAAKkB,UAAY,GAvBhB,2BAwBD,YAAwBlB,KAAKC,WAA7B,+CAAyC,CAAC,IAA/BC,EAA8B,QAClCoC,EAAgBN,EAAK9B,GAErBO,EAAkByB,EAAQK,KAAKD,IAAW,KAEhDtC,KAAKkB,UAAUhB,GAAaO,GA7B5B,kFAiCDT,KAAKiB,SAAWe,M,KA8CZQ,EAAiB,SACtB1B,EACA2B,GAGA,IAAMC,EAAc5B,EAAWe,QAAO,SACrCR,EACAC,GAEA,OAAOD,EAAIC,KAGNqB,EAAsB,YAAOC,MAAMF,GAAMnB,QACzCsB,EAA2B,GAkCjC,OA7BAF,EAASnB,SAAQ,SAChBsB,GAEA,IAAIC,GAAkB,EAEtBN,EAAYjB,SAAQ,SACnBwB,EACAC,GAEA,QAAwB9C,IAApB6C,EAA+B,CAClC,IAAME,EAA0BpC,EAAWmC,GAErCE,EADmCrC,EAAWc,MAAM,EAAGqB,GACjBpB,QAAO,SAClDR,EACAC,GAEA,OAAOD,EAAIC,IACT,GAGC8B,KAAKC,MAAMP,EAAYK,GAAaD,IAAqBF,IAC5DD,GAAU,OAITA,GACHF,EAAWlB,KAAKmB,MAGXD,GAMKS,EAAb,YACC,WACCxC,GACE,IAAD,sBACD,4CAAMA,IADL,kBAGc,EAAKE,YAHnB,GAGMuC,EAHN,KAGSC,EAHT,YAKD,EAAKxB,KAAO,CACX,OAAUwB,EACV,OAAUA,EACV,MAAUD,EACV,MAAUA,GATV,EAHH,oEAiBEd,GAEA,OAAOD,EAAexC,KAAKe,YAAa0B,KAnB1C,mCAuBEf,GAEA,OAxGmB,SACpBZ,EACAY,GAEA,IAAMe,EAA4B,GAelC,OAdA3B,EAAWU,SAAQ,SAClB0B,EACAD,GAEA,IACME,EADkCrC,EAAWc,MAAM,EAAGqB,GACjBpB,QAAO,SACjDR,EACAC,GAEA,OAAOD,EAAIC,IACT,GACGmC,EAAoBL,KAAKC,MAAM3B,EAAQyB,GAAaD,EAC1DT,EAAYd,KAAK8B,MAEXhB,EAqFCiB,CAAa1D,KAAKe,YAAaW,OAzBxC,GAAqCb,GClKhB8C,E,WAKpB,WACC7C,GACE,yBANHA,gBAME,OALFlB,aAKE,OAJF8C,UAIE,OAHFP,SAGE,EACDnC,KAAKc,WAAaA,EAClBd,KAAKJ,QAAU,IAAI0D,EAAgBxC,GACnCd,KAAK0C,KAAO5B,EAAWe,QAAO,SAACR,EAAGC,GACjC,OAAOD,EAAIC,KAEZtB,KAAKmC,IAAM,IAAIS,MAAM5C,KAAK0C,MAC1B1C,KAAK4D,SAAS,G,uDAIdlC,GAEA,OAAO,GAAKA,GAASA,EAAQ1B,KAAK0C,O,qCAIlCmB,EACAC,GAKA,IACE9D,KAAK+D,WAAWF,KACb7D,KAAK+D,WAAWD,GAEpB,OAAO,EAIR,IAAME,EAA6BhE,KAAKJ,QAAQ8D,aAAaG,GACvDI,EAA6BjE,KAAKJ,QAAQ8D,aAAaI,GAGzDI,EAAqB,EAazB,OAXAF,EAAaxC,SAAQ,SACpB2C,EACAtE,GAGIsE,IADuBF,EAAapE,KAEvCqE,GAAe,QAKbA,EAAc,K,+BAQlBxC,GACE,IAAD,OAWK0C,EAAmB,IAAIzE,EAAKK,KAAKJ,QAAS8B,GA0ChD,OAzCA1B,KAAKmC,IAAIT,GAAS0C,EC9EG,SACtBC,GAMA,IAHgB,IAFhBC,EAEe,uDAFAD,EAAME,OACrBC,EACe,uDADGpB,KAAKoB,OAEjBjD,EAAI,YAAO8C,GACXI,EAAU,GACPC,EAAE,EAAGA,EAAEJ,EAAOI,IAAK,CAC3B,IAAMC,EAAOvB,KAAKC,MAAMmB,IAAWjD,EAAKgD,QACxCE,EAAQ9C,KAAKJ,EAAKoD,IAClBpD,EAAKqD,OAAOD,EAAM,GAEnB,OAAOF,EDqE8BI,CAAQ,YAAI7E,KAAKJ,QAAQK,aAC/CuB,SAAQ,SAACtB,GAGtB,IACI4E,EADEC,EAAuB,EAAKnF,QAAQmC,OAAOL,GAAOxB,GAKnD,EAAK6D,WAAWgB,IACjB,EAAKC,eAAetD,EAAOqD,QAQQ5E,IAA5B,EAAKgC,IAAI4C,IAEnBD,EAAe,EAAKlB,SAASmB,GAE7BX,EAAYa,iBAAiBH,EAAc5E,GAC3CkE,EAAYc,iBAAiBJ,EAAc5E,IAGjC,EAAKiC,IAAI4C,aAA0BpF,IAG7CmF,EAAe,EAAK3C,IAAI4C,GAExBX,EAAYa,iBAAiBH,EAAc5E,IAnB3CkE,EAAW,UAAclE,GAAa,QA0BjCkE,M,KEvHYe,E,WAEpB,WAAYC,GAAY,yBADxBA,UACuB,EACtBpF,KAAKoF,KAAOA,E,uDAGA,IAAD,OAOPC,EAAS,GAoBb,OAjBArF,KAAKoF,KAAKjD,IAAIX,SAAQ,SACrB8D,EACA5D,GAGA,IAAM6D,EAAgBD,EAAI,SAAJ,MAChBE,EAAgBF,EAAI,SAAJ,MAChBG,EAAeH,EAAI,SAAJ,KACfI,EAAeJ,EAAI,SAAJ,KAGjB5D,EAAQ,EAAK0D,KAAKtE,WAAW,KAAO,IACvCuE,GAAU,MAGXA,GAAUM,EAASJ,EAAOC,EAAOC,EAAMC,EAAM,WAEvCL,M,KA8HHM,EAAW,SAChBJ,EACAC,EACAC,EACAC,EACAE,GAWA,IAAIC,EAAO,GACPC,EAAO,GA4EX,OAzEIP,GAASC,GAASC,GAAQC,GAC7BI,EAAO,IACPD,EAAO,UAICL,GAASC,GAAQC,IAAUH,GACnCO,EAAO,SACPD,EAAO,UAECN,GAASE,GAAQC,IAAUF,GACnCM,EAAO,SACPD,EAAO,UAECN,GAASC,GAASE,IAAUD,GACpCK,EAAO,SACPD,EAAO,UAECN,GAASC,GAASC,IAAUC,GACpCI,EAAO,SACPD,EAAO,UAICN,GAASC,IAAWC,IAAQC,GACpCI,EAAO,SACPD,EAAO,UAECN,GAASE,IAAUD,IAASE,GACpCI,EAAO,SACPD,EAAO,UAECN,GAASG,IAAUF,IAASC,GACpCK,EAAO,SACPD,EAAO,UAECL,GAASC,IAAUF,IAASG,GACpCI,EAAO,SACPD,EAAO,UAECL,GAASE,IAAUH,IAASE,GACpCK,EAAO,SACPD,EAAO,UAECJ,GAAQC,IAAUH,IAASC,GACnCM,EAAO,SACPD,EAAO,UAICN,KAAWC,GAASC,GAAQC,IACpCI,EAAO,SACPD,EAAO,UAECL,KAAWD,GAASE,GAAQC,IACpCI,EAAO,SACPD,EAAO,UAECJ,KAAUF,GAASC,GAASE,IACpCI,EAAO,SACPD,EAAO,UAECH,KAAUH,GAASC,GAASC,IACpCK,EAAO,SACPD,EAAO,UAIGN,GAASC,GAASC,GAAQC,IACpCI,EAAO,SACPD,EAAO,KAGK,SAATD,EACIE,EAEAD,GC5PHE,EAAS,IAAIpC,EAAK,CAAC,GAAG,KACtBqC,EAAY,IAAIC,EAAQF,GAE9BG,QAAQC,IAAIJ,GAEZ,IA2BeK,EA3BH,WAAO,IAAD,EACSC,mBAASL,EAAUM,YAD5B,mBACVC,EADU,KACHC,EADG,KAEjB,OACC,oCACC,8CACA,yEAGA,2BACCZ,KAAK,SACLa,QAAS,WACR,IAAMC,EAAU,IAAI/C,EAAK,CAAC,GAAG,KACvBgD,EAAa,IAAIV,EAAQS,GAC/BF,EAASG,EAAWL,aAErBM,MAAM,aAGP,8BACCC,UAAU,UACVD,MAAOL,EACPO,UAAU,MCnBMC,QACU,cAA7BC,OAAOC,SAASC,UAEc,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACxB,2DCZHC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SDqI5C,kBAAmBC,WACtBA,UAAUC,cAAcC,MACtBC,MAAK,SAAAC,GACLA,EAAaC,gBAEbC,OAAM,SAAAC,GACN7B,QAAQ6B,MAAMA,EAAMC,c","file":"static/js/main.b3e7d23d.chunk.js","sourcesContent":["import Compass from './compass'\n\nexport default class Cell {\n\tpublic position:number\n\tpublic pathways:{[key:string]:boolean}\n\tpublic neighbors:{[key:string]:Cell|undefined|null}\n\tprivate readonly compass:Compass\n\tconstructor (\n\t\tcompass:Compass,\n\t\tposition:number,\n\t) {\n\t\t// initialize basic information.\n\t\tthis.position = position\n\t\tthis.compass = compass\n\n\t\t// initialize pathways & neighbors.\n\t\tthis.pathways = {}\n\t\tthis.neighbors = {}\n\t\tfor (const direction of this.compass.directions) {\n\t\t\tthis.pathways[direction] = false\n\t\t\tthis.neighbors[direction] = undefined\n\t\t}\n\t}\n\n\tpublic get boundaries ():{[key:string]:boolean} {\n\t\t// boundaries is the opposite of pathways.\n\t\tconst boundaries:{[key:string]:boolean} = {}\n\t\t// loop through pathways and reverse values for boundaries.\n\t\tfor (const [direction, isPath] of Object.entries(this.pathways)) {\n\t\t\tboundaries[direction] = !isPath\n\t\t}\n\t\t// there you have it!\n\t\treturn boundaries\n\t}\n\n\tpublic hasPath ():boolean {\n\t\t// a direction is either a wall (false) or path (true).\n\t\t// check if there's any pathways in the values.\n\t\treturn Object.values(this.pathways).includes(true)\n\t\t// `.values()` makes a list of booleans from pathways.\n\t\t// `.includes()` creates a boolean, which is returned.\n\t}\n\n\tpublic hasWall ():boolean {\n\t\t// a direction is either a wall (true) or path (false).\n\t\t// check if there's any boundaries in the values.\n\t\treturn Object.values(this.boundaries).includes(true)\n\t\t// `.values()` makes a list of booleans from boundaries.\n\t\t// `.includes()` creates a boolean, which is returned.\n\t}\n\n\tpublic isNeighborsWith (\n\t\tthat:Cell,\n\t):boolean {\n\t\t// check if this is a neighbor of that.\n\t\treturn Object.values(this.neighbors).includes(that)\n\t\t// `.values()` makes a list of cells from neighbors.\n\t\t// `.includes()` creates a boolean, which is returned.\n\t}\n\n\tpublic joinWithNeighbor (\n\t\tthat:Cell,\n\t\tdirection:string,\n\t):void {\n\t\t// `reversed` is the antipode of a direction.\n\t\t// for example, `reversed` of 'north' is 'south'.\n\t\tconst reversed:string = this.compass.reverse(direction)\n\t\t// set neighbors.\n\t\tthis.neighbors[direction] = that\n\t\tthat.neighbors[reversed] = this\n\t}\n\n\tpublic pathWithNeighbor (\n\t\tthat:Cell,\n\t\tdirection:string,\n\t):void {\n\t\t// `reversed` is the antipode of a direction.\n\t\t// for example, `reversed` of 'north' is 'south'.\n\t\tconst reversed:string = this.compass.reverse(direction)\n\t\t// set pathways.\n\t\tthis.pathways[direction] = true\n\t\tthat.pathways[reversed] = true\n\t}\n\n}\n\n// valid connected neighbors -> neighbor and true\n","export default class Compass {\n\tprotected readonly _dimensions:Array<number>\n\tprotected readonly _magnitudes:Array<number>\n\tprotected _magnets: {[key:string]:number}\n\tpublic opposites: {[key:string]:string}\n\tpublic directions: Set<string>\n\tconstructor (\n\t\tdimensions:Array<number>\n\t) {\n\t\t// create a multiplier affect for magnitudes.\n\t\tconst magnitudes:Array<number> = []\n\t\tconst multiplier = (a:number, b:number):number => a * b\n\t\t// loop through the size of each dimension.\n\t\tObject.keys(dimensions).forEach((\n\t\t\t_:any,\n\t\t\tindex:number,\n\t\t) => {\n\t\t\tmagnitudes.push(\n\t\t\t\tdimensions.slice(0, index).reduce(multiplier, 1)\n\t\t\t)\n\t\t})\n\t\tthis._dimensions = dimensions\n\t\tthis._magnitudes = magnitudes\n\t\tthis._magnets = {}\n\t\tthis.opposites = {}\n\t\tthis.directions = new Set()\n\t}\n\n\tpublic get rose ():{[key:string]:number} {\n\t\treturn this._magnets\n\t}\n\n\tpublic set rose (\n\t\trose:{[key:string]:number}\n\t) {\n\t\t// `directions` is a simple set of named vectors.\n\t\t// luckily, these are exactly the keys of `rose`.\n\t\tthis.directions = new Set(Object.keys(rose))\n\n\n\t\t// `opposites` is a harder nut to crack.\n\t\t// the app reverses the keys into a JavaScript Map.\n\t\t// since the keys are numbers, they can be inverted.\n\t\t// use that to find the opposing direction string.\n\t\tconst reducer = (\n\t\t\tmap:Map<number, string>,\n\t\t\tdirection:string,\n\t\t):Map<number, string> => {\n\t\t\t// compute the `vector` of the direction.\n\t\t\tmap.set(rose[direction], direction)\n\t\t\treturn map\n\t\t}\n\t\tconst vectors:Map<number, string> = (\n\t\t\t// set the `vectors` into a map with reduce.\n\t\t\tObject.keys(rose).reduce(reducer, new Map())\n\t\t)\n\t\t// initialize opposites.\n\t\tthis.opposites = {}\n\t\tfor (const direction of this.directions) {\n\t\t\tconst vector:number = rose[direction]\n\t\t\t// TODO -> bad `|| 'none'`\n\t\t\tconst reversed:string = vectors.get(-vector) || ':('\n\t\t\t// here is where reverse-directions is set!\n\t\t\tthis.opposites[direction] = reversed\n\t\t}\n\n\t\t// finally, just return the new rose as the new magnets.\n\t\tthis._magnets = rose\n\t}\n\n\tpublic reverse(direction:string):string {\n\t\t// directly pulling from `opposites` would be easy...\n\t\t// ...but, it seems more semantic using a method here!\n\t\treturn this.opposites[direction]\n\t}\n\n\tpublic offset (\n\t\tindex:number,\n\t):{[key:string]:number} {\n\t\tconst offset:{[key:string]:number} = {}\n\t\tfor (const [direction, modifier] of Object.entries(this.rose)) {\n\t\t\toffset[direction] = index + modifier\n\t\t}\n\t\treturn offset\n\t}\n}\n\nconst triangulator = (\n\tdimensions:Array<number>,\n\tindex:number,\n):Array<number> => {\n\tconst coordinates:Array<number> = []\n\tdimensions.forEach((\n\t\tcurrentDimension:number,\n\t\tpositionIndex:number,\n\t):void => {\n\t\tconst leadingDimensions:Array<number> = dimensions.slice(0, positionIndex)\n\t\tconst magnitude:number = leadingDimensions.reduce((\n\t\t\ta:number,\n\t\t\tb:number,\n\t\t):number => {\n\t\t\treturn a * b\n\t\t}, 1)\n\t\tconst coordinate:number = Math.floor(index / magnitude) % currentDimension\n\t\tcoordinates.push(coordinate)\n\t})\n\treturn coordinates\n}\n\n\n// tetragonSlicer takes in the map's dimensions,\n// and then the cell's coordinates.\n// it returns a slice of the desired coordinates.\nconst tetragonSlicer = (\n\tdimensions:Array<number>,\n\tcoordinates:Array<number|undefined>,\n):Array<number> => {\n\n\tconst size:number = dimensions.reduce((\n\t\ta:number,\n\t\tb:number,\n\t):number => {\n\t\treturn a * b\n\t})\n\n\tconst allCells:Array<number> = [...Array(size).keys()]\n\tconst validCells:Array<number> = []\n\n\t// this piece creates spacers or iterators.\n\t// if we have dimensions of [5,4,3] our spacers are:\n\t// [1,5,20,60]. The final item = total # of coordinates.\n\tallCells.forEach((\n\t\tcellIndex:number\n\t):void => {\n\t\tlet isValid:boolean = true\n\n\t\tcoordinates.forEach((\n\t\t\tcurrentPosition:number|undefined,\n\t\t\tpositionIndex:number,\n\t\t):void => {\n\t\t\tif (currentPosition !== undefined) {\n\t\t\t\tconst currentDimension:number = dimensions[positionIndex]\n\t\t\t\tconst previousDimensions:Array<number> = dimensions.slice(0, positionIndex)\n\t\t\t\tconst magnitude:number = previousDimensions.reduce((\n\t\t\t\t\ta:number,\n\t\t\t\t\tb:number,\n\t\t\t\t):number => {\n\t\t\t\t\treturn a * b\n\t\t\t\t}, 1)\n\n\t\t\t\t// check if the cell index is valid right now...\n\t\t\t\tif (Math.floor(cellIndex / magnitude) % currentDimension !== currentPosition) {\n\t\t\t\t\tisValid = false\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tif (isValid) {\n\t\t\tvalidCells.push(cellIndex)\n\t\t}\n\t})\n\treturn validCells\n}\n\n// a tetragon is a four-sided polygon.\n// a quadrilateral is a four-angled polygon.\n// they mean the same thing.\nexport class TetragonCompass extends Compass {\n\tconstructor (\n\t\tdimensions:Array<number>\n\t) {\n\t\tsuper(dimensions)\n\t\t// deconstruct magnitudes for each axis.\n\t\tconst [x, y] = this._magnitudes\n\t\t// generate a rose of index-offsetters.\n\t\tthis.rose = {\n\t\t\t'north': -y,\n\t\t\t'south': +y,\n\t\t\t'east':  +x,\n\t\t\t'west':  -x,\n\t\t}\n\t}\n\n\tslicer (\n\t\tcoordinates:Array<number|undefined>\n\t):Array<number> {\n\t\treturn tetragonSlicer(this._dimensions, coordinates)\n\t}\n\n\ttriangulator (\n\t\tindex:number\n\t):Array<number> {\n\t\treturn triangulator(this._dimensions, index)\n\t}\n}\n\n// a hexahedron is a six-sided polyhedron.\nexport class HexahedronCompass extends Compass {\n\tconstructor (\n\t\tdimensions:Array<number>\n\t) {\n\t\tsuper(dimensions)\n\t\t// deconstruct magnitudes for each axis.\n\t\tconst [x, y, z] = this._magnitudes\n\t\t// generate a rose of index-offsetters.\n\t\tthis.rose = {\n\t\t\t'above': -z,\n\t\t\t'below': +z,\n\t\t\t'north': -y,\n\t\t\t'south': +y,\n\t\t\t'east':  -x,\n\t\t\t'west':  +x,\n\t\t}\n\t}\n\n\tslicer (\n\t\tcoordinates:Array<number|undefined>\n\t):Array<number> {\n\t\treturn tetragonSlicer(this._dimensions, coordinates)\n\t}\n}\n\n// a hexahedron is a six-sided polygon.\nexport class HexagonCompass extends Compass {\n\tconstructor (\n\t\tdimensions:Array<number>\n\t) {\n\t\tsuper(dimensions)\n\t\t// deconstruct magnitudes for each axis.\n\t\tconst [x, y] = this._magnitudes\n\t\t// generate a rose of index-offsetters.\n\t\tthis.rose = {\n\t\t\t'northwest': -y,\n\t\t\t'southeast': +y,\n\t\t\t'northeast': x - y,\n\t\t\t'southwest': y - x,\n\t\t\t'east': -x,\n\t\t\t'west': +x,\n\t\t}\n\t}\n}\n\n/***************************NOTES***************************\n==NOTE==\n- `Compass` is a default class so that it can be typecast.\n\n==TODO==\n- the for loop in the primary class is suboptimal.\n- `this._magnitudes` is not the greatest name; rename it.\n***********************************************************/\n","import Cell from './cell'\nimport {TetragonCompass} from './compass'\nimport {shuffle} from '../helpers/shuffle'\n\nexport default class Maze {\n\tdimensions:Array<number>\n\tcompass:TetragonCompass\n\tsize:number\n\tmap:Array<Cell|undefined|null>\n\tconstructor(\n\t\tdimensions:Array<number>,\n\t) {\n\t\tthis.dimensions = dimensions\n\t\tthis.compass = new TetragonCompass(dimensions)\n\t\tthis.size = dimensions.reduce((a, b) => {\n\t\t\treturn a * b\n\t\t})\n\t\tthis.map = new Array(this.size)\n\t\tthis.generate(0)\n\t}\n\n\tvalidIndex (\n\t\tindex:number,\n\t):boolean {\n\t\treturn 0 <= index && index < this.size\n\t}\n\n\tvalidNeighbors (\n\t\tindex1:number,\n\t\tindex2:number,\n\t):boolean {\n\t\t// helper function.\n\t\t// removes neighbors that are invalid in some way,\n\t\t// such as being out of bounds or across the map.\n\t\tif (\n\t\t\t!this.validIndex(index1)\n\t\t\t|| !this.validIndex(index2)\n\t\t) {\n\t\t\treturn false\n\t\t}\n\n\t\t// calculate coordinates.\n\t\tconst coordinates1:Array<number> = this.compass.triangulator(index1)\n\t\tconst coordinates2:Array<number> = this.compass.triangulator(index2)\n\n\t\t// count the differences.\n\t\tlet differences:number = 0\n\t\t// the coordinates must share all but one dimension.\n\t\tcoordinates1.forEach((\n\t\t\tcoordinate1:number,\n\t\t\tposition:number,\n\t\t) => {\n\t\t\tconst coordinate2:number = coordinates2[position]\n\t\t\tif (coordinate1 !== coordinate2) {\n\t\t\t\tdifferences += 1\n\t\t\t}\n\t\t})\n\n\t\t// now, check the differences, and return.\n\t\tif (differences > 1) {\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tgenerate (\n\t\tindex:number\n\t) {\n\t\t// generates a perfect maze.\n\t\t// its done recursively via a depth-first traversal tree.\n\t\t// this is a setter function; it does not return anything.\n\t\t// ---\n\t\t// compass = cardinal direction\n\t\t// reverse = reversed cardinal direction\n\t\t// root_pos = root position\n\t\t// neighbor = neighbor position\n\n\t\t// first, fill the maze spot with an empty cell.\n\t\tconst currentCell:Cell = new Cell(this.compass, index)\n\t\tthis.map[index] = currentCell\n\n\t\t// next, randomize compass order and loop through.\n\t\tconst randomCompass:Array<string> = shuffle([...this.compass.directions])\n\t\trandomCompass.forEach((direction:string):void => {\n\n\t\t\t// get the index of the neighbor via direction.\n\t\t\tconst neighborIndex:number = this.compass.offset(index)[direction]\n\t\t\tlet neighborCell:Cell\n\n\t\t\t// if validating the neighborIndex fails, then the\n\t\t\t// neighborIndex is a maze boundary.\n\t\t\tif (!this.validIndex(neighborIndex)\n\t\t\t|| !this.validNeighbors(index, neighborIndex)) {\n\t\t\t\t// null represents such a boundary.\n\t\t\t\tcurrentCell['neighbors'][direction] = null\n\t\t\t\t// continue to next loop item...\n\n\t\t\t// otherwise the neighborCell should exist.\n\t\t\t// if the the neighborIndex points to undefined,\n\t\t\t// then we can visit the index and fill the Cell.\n\t\t\t} else if (this.map[neighborIndex] === undefined) {\n\t\t\t\t// generate a new maze block with the neighborIndex.\n\t\t\t\tneighborCell = this.generate(neighborIndex)\n\t\t\t\t// link up the net / graph / tree.\n\t\t\t\tcurrentCell.joinWithNeighbor(neighborCell, direction)\n\t\t\t\tcurrentCell.pathWithNeighbor(neighborCell, direction)\n\n\t\t\t// if the Cell already exists, we can't hook it up.\n\t\t\t} else if (this.map[neighborIndex] instanceof Cell) {\n\t\t\t\t// this spot is not empty.\n\t\t\t\t// @ts-ignore\n\t\t\t\tneighborCell = this.map[neighborIndex]\n\t\t\t\t// link up the net / graph / tree.\n\t\t\t\tcurrentCell.joinWithNeighbor(neighborCell, direction)\n\t\t\t}\n\t\t})\n\n\t\t// this current cell is used in the stack upstream.\n\t\t// if this is the root cell, the returned item\n\t\t// simply might not be caught by anything.\n\t\treturn currentCell\n\t}\n}\n\n/*\n\tdef shortest_path_bfs(self, paths=None, A=None, B=None):\n\t\t'''\n\t\tA = given starting node\n\t\tB = given finishing node\n\t\tC = arbitrary iterated node\n\t\ta_list = traversed list of nodes\n\t\tb_list = traversed list of nodes\n\t\tc_list = traversed list of nodes\n\t\tqueue:\n\t\tvisited: set of visited vertices\n\t\tvertices: every single vertex in the graph\n\t\t'''\n\t\t# set up default parameters.\n\t\tif A is None or B is None:\n\t\t\t# a_loc = random.randint(0, 0)\n\t\t\t# b_loc = random.randint(0, len(self.maze) - 1)\n\t\t\ta_loc = 0\n\t\t\tb_loc = len(self.maze) - 1\n\t\t\tprint('find', b_loc)\n\t\t\tA = self.maze[a_loc]\n\t\t\tB = self.maze[b_loc]\n\t\t# create vertex queue, and start with vertex A.\n\t\tqueue = [[A]]  # HACK not a real queue.\n\t\t# create visited set, and start with vertex A.\n\t\tvisited = {A}\n\n\t\twhile queue != []:\n\t\t\t# dequeue first vertex.\n\t\t\t# HACK change later for non-array.\n\t\t\ta_list = queue.pop()\n\t\t\tA = a_list[-1]\n\t\t\t# check a condition.\n\t\t\tif A == B:\n\t\t\t\tprint(len(a_list), 'steps')\n\t\t\t\treturn a_list\n\t\t\t# add its neighbors to the queue.\n\t\t\tfor compass in A.neighbors:\n\t\t\t\t# get vertex from compass.\n\t\t\t\tC = A.neighbors[compass]\n\t\t\t\t# pass if neighbor does not exist.\n\t\t\t\tif C is None or C is False:\n\t\t\t\t\tpass\n\t\t\t\t# pass if neighbor has been visited already.\n\t\t\t\telif C in visited:\n\t\t\t\t\tpass\n\t\t\t\telse:\n\t\t\t\t\t# visit the vertex.\n\t\t\t\t\tvisited.add(C)\n\t\t\t\t\t# HACK change later for non-array.\n\t\t\t\t\tc_list = a_list[:]\n\t\t\t\t\tc_list.append(C)\n\t\t\t\t\tqueue.insert(0, c_list)\n\t\treturn paths\n\n/*\n\tdef aerate_maze(self, n=1):\n\t\t'''\n\t\tdeletes n random walls to destroy trees.\n\t\tthis could make a maze easier or harder.\n\t\t'''\n\t\t# this will allow us to iterate through blocks.\n\t\t# we want to find a block with a blocked neighbor.\n\t\tunvisited = list(range(0, len(self.maze)))\n\t\trandom.shuffle(unvisited)\n\n\t\t# loop through until its found\n\t\tblock_id = None\n\t\tblock = None\n\t\tfound = False\n\t\twhile not found:\n\t\t\t# pick out a random block.\n\t\t\tblock_id = unvisited.pop()\n\t\t\tblock = self.maze[block_id]\n\t\t\t# check its neighbors.\n\t\t\tfor compass in block.neighbors:\n\t\t\t\tneighbor = block.neighbors[compass]\n\t\t\t\t# see if it has a blocked off neighbor.\n\t\t\t\tif block.neighbors[compass] is False:\n\t\t\t\t\tfound = True\n\n\t\t# randomize compass order.\n\t\trandom_neighbors = list(block.neighbors.items())\n\t\trandom.shuffle(random_neighbors)\n\n\t\t# neighbors\n\t\tsibling_id = None\n\t\tsibling = None\n\n\t\t# check its compass neighbors.\n\t\tfor compass, neighbor in random_neighbors:\n\t\t\tif neighbor is False:\n\t\t\t\tif compass == 'north':\n\t\t\t\t\tsibling_id = block_id - self.length\n\t\t\t\telif compass == 'south':\n\t\t\t\t\tsibling_id = block_id + self.length\n\t\t\t\telif compass == 'east':\n\t\t\t\t\tsibling_id = block_id + 1\n\t\t\t\telif compass == 'west':\n\t\t\t\t\tsibling_id = block_id - 1\n\t\t\t\tsibling = self.maze[sibling_id]\n\t\t\t\tbreak\n\n\t\t# this is useful for doubly-linked vertices.\n\t\treverse_compass = {\n\t\t\t'north': 'south',\n\t\t\t'south': 'north',\n\t\t\t'east': 'west',\n\t\t\t'west': 'east',\n\t\t}\n\n\t\t# reverse reverses compass, a cardinal direction.\n\t\treverse = reverse_compass[compass]\n\n\t\t# finally set the new connection!\n\t\tblock.neighbors[compass] = sibling\n\t\tsibling.neighbors[reverse] = block\n\n\t\t# keep going if n is more than 1.\n\t\tn -= 1\n\t\tif n > 0:\n\t\t\tself.aerate_maze(n)\n*/\n\n/***********************************************************\nThis section describes footnotes & comments for the project.\nThese should mostly contain bugs and todo items.\n\n== TODO ==\nMaze array should have a fixed size:\nsize = maze length × maze height\n\n== TODO ==\nMaze class only supports 2D-Square mazes.\nAdd support for ND-polyhedral mazes.\n\n== TODO ==\nMaze class only supports breadth-first traversal.\nAdd support for other maze-generation algorithms.\n\n***********************************************************/\n","// random shuffle helper function\n// uses fisher yates randomizer\nexport const shuffle = (\n\tarray:Array<any>,\n\titems:number = array.length,\n\trandom:Function = Math.random,\n):Array<any> => {\n\tconst keys = [...array] // create copy\n\tconst results = []\n\tfor (let i=0; i<items; i++) {\n\t\tconst roll = Math.floor(random() * keys.length)\n\t\tresults.push(keys[roll])\n\t\tkeys.splice(roll, 1)\n\t}\n\treturn results\n}\n","import Maze from './maze'\n\nexport default class UnicodeGraphic {\n\tmaze:Maze\n\tconstructor(maze:Maze) {\n\t\tthis.maze = maze\n\t}\n\n\tpipeMaze () {\n\t\t// a pipe-maze is much more simple to make.\n\t\t// a player must follow lines to complete the maze.\n\t\t// while less traditional, it is very easy to make.\n\t\t// each vertex determinse a unicode character.\n\n\t\t//initialize empty result string.\n\t\tlet result = ''\n\n\t\t// loop through maze.\n\t\tthis.maze.map.forEach((\n\t\t\tcell:any,\n\t\t\tindex:number,\n\t\t):void => {\n\t\t\t// assumes there is a path in every direction.\n\t\t\tconst north:boolean = cell['pathways']['north']\n\t\t\tconst south:boolean = cell['pathways']['south']\n\t\t\tconst east:boolean = cell['pathways']['east']\n\t\t\tconst west:boolean = cell['pathways']['west']\n\n\t\t\t// add line break if end of line is reached\n\t\t\tif (index % this.maze.dimensions[0] === 0) {\n\t\t\t\tresult += '\\n'\n\t\t\t}\n\t\t\t// get the symbol to be added to the result string\n\t\t\tresult += getGlyph(north, south, east, west, 'pipe')\n\t\t})\n\t\treturn result\n\t}\n}\n\n/*\n\tdef edge_maze(self):\n\t\t'''\n\t\tan edge-maze is a traditional-looking maze.\n\t\ta player must follow the space between lines to finish.\n\t\thowever, this algorithm is also more complex.\n\t\tit must look at 4 nodes to determine 1 unicode glyph.\n\t\t'''\n\t\t# HACK reassigning self for convenience.\n\t\tself = self.maze_object\n\n\t\t# store result item\n\t\tresult = ''\n\n\t\t# the padding helps analyze corners and boundaries.\n\t\tpadded_length = self.length + 2\n\t\tpadded_height = self.height + 2\n\t\tpadded_maze = [None] * padded_length * padded_height\n\n\t\t# graphics are ultimately what we are aiming to find.\n\t\tgraphic_length = self.length + 1\n\t\tgraphic_height = self.height + 1\n\t\tgraphic_maze = [None] * graphic_length * graphic_height\n\n\t\t# this thing preps for calculations with graphics.\n\t\tfor location, reference in enumerate(padded_maze):\n\t\t\t# determine row and column\n\t\t\trow = location // (padded_length)\n\t\t\tcolumn = location % (padded_length)\n\n\t\t\t# checks if the item is padding for the boundary.\n\t\t\tif (row == 0\n\t\t\t\tor column == 0\n\t\t\t\tor row == padded_height - 1\n\t\t\t\t\tor column == padded_length - 1):\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\treference = location - padded_length + 1 - row * 2\n\t\t\t\tpadded_maze[location] = reference\n\n\t\t# this thing calculates the graphics.\n\t\tfor location, reference in enumerate(graphic_maze):\n\t\t\t# determine row and column\n\t\t\trow = location // (graphic_length)\n\t\t\tcolumn = location % (graphic_length)\n\t\t\tlocation = location + row\n\n\t\t\t# determines locations of items in the padded_maze.\n\t\t\tnw_loc = padded_maze[location]\n\t\t\tne_loc = padded_maze[location + 1]\n\t\t\tsw_loc = padded_maze[location + padded_length]\n\t\t\tse_loc = padded_maze[location + padded_length + 1]\n\n\t\t\t# initialize hallway passageways.\n\t\t\t# if there is a passway, then its true, else false.\n\t\t\t# none indicates an undeterminate value.\n\t\t\tn_hall = None\n\t\t\ts_hall = None\n\t\t\te_hall = None\n\t\t\tw_hall = None\n\n\t\t\t# this section is looking at edge pieces.\n\t\t\t# there is only empty space beyond an edge.\n\t\t\t# these ternary operators determines this.\n\t\t\t# north boundary\n\t\t\tif (nw_loc is None\n\t\t\t\t\tand ne_loc is None):\n\t\t\t\tn_hall = True\n\t\t\t# south boundary\n\t\t\tif (sw_loc is None\n\t\t\t\t\tand se_loc is None):\n\t\t\t\ts_hall = True\n\t\t\t# east boundary\n\t\t\tif (ne_loc is None\n\t\t\t\t\tand se_loc is None):\n\t\t\t\te_hall = True\n\t\t\t# west boundary\n\t\t\tif (nw_loc is None\n\t\t\t\t\tand sw_loc is None):\n\t\t\t\tw_hall = True\n\n\t\t\t# verify if there is a path in any direction.\n\t\t\t# remember, this glyph represents a wall, not a space.\n\t\t\t# this is checking each path adjacent to the wall.\n\t\t\t# north path\n\t\t\tif ne_loc is not None and nw_loc is not None:\n\t\t\t\teast = self.maze[ne_loc]\n\t\t\t\twest = self.maze[nw_loc]\n\t\t\t\tif (east.neighbors['west'] == west\n\t\t\t\t\t\tand west.neighbors['east'] == east):\n\t\t\t\t\tn_hall = True\n\t\t\t# south path\n\t\t\tif se_loc is not None and sw_loc is not None:\n\t\t\t\teast = self.maze[se_loc]\n\t\t\t\twest = self.maze[sw_loc]\n\t\t\t\tif (east.neighbors['west'] == west\n\t\t\t\t\t\tand west.neighbors['east'] == east):\n\t\t\t\t\ts_hall = True\n\t\t\t# east path\n\t\t\tif ne_loc is not None and se_loc is not None:\n\t\t\t\tnorth = self.maze[ne_loc]\n\t\t\t\tsouth = self.maze[se_loc]\n\t\t\t\tif (north.neighbors['south'] == south\n\t\t\t\t\t\tand south.neighbors['north'] == north):\n\t\t\t\t\te_hall = True\n\t\t\t# west path\n\t\t\tif nw_loc is not None and sw_loc is not None:\n\t\t\t\tnorth = self.maze[nw_loc]\n\t\t\t\tsouth = self.maze[sw_loc]\n\t\t\t\tif (north.neighbors['south'] == south\n\t\t\t\t\t\tand south.neighbors['north'] == north):\n\t\t\t\t\tw_hall = True\n\n\t\t\t# add a line break if its an end-of-line.\n\t\t\tif location % padded_length == 0 and location != 0:\n\t\t\t\tresult += '\\n'\n\t\t\t# get unicode glyph symbol box-drawing element.\n\t\t\tresult += getGlyph(n_hall, s_hall, e_hall, w_hall, 'edge')\n\t\t# return maze drawing.\n\t\treturn result\n*/\n\nconst getGlyph = (\n\tnorth:boolean,\n\tsouth:boolean,\n\teast:boolean,\n\twest:boolean,\n\ttype:string,\n):string => {\n\n\t// this function returns a maze drawing character.\n\t// == TODO ==\n\t// this is awkwardly large.\n\t// not sure where to put it semantically.\n\t// == FIXME ==\n\t// these unicode characters must be converted!\n\t// like emojis, its a code smell to have them.\n\n\tlet pipe = ''\n\tlet edge = ''\n\n\t// four passages\n\tif (north && south && east && west) {\n\t\tedge = ' '\n\t\tpipe = '┼'\n\t}\n\n\t// three passages\n\telse if (south && east && west && !(north)) {\n\t\tedge = '╵'\n\t\tpipe = '┬'\n\t}\n\telse if (north && east && west && !(south)) {\n\t\tedge = '╷'\n\t\tpipe = '┴'\n\t}\n\telse if (north && south && west && !(east)) {\n\t\tedge = '╶'\n\t\tpipe = '┤'\n\t}\n\telse if (north && south && east && !(west)) {\n\t\tedge = '╴'\n\t\tpipe = '├'\n\t}\n\n\t// two passages\n\telse if (north && south && !(east || west)) {\n\t\tedge = '─'\n\t\tpipe = '│'\n\t}\n\telse if (north && east && !(south || west)) {\n\t\tedge = '┐'\n\t\tpipe = '└'\n\t}\n\telse if (north && west && !(south || east)) {\n\t\tedge = '┌'\n\t\tpipe = '┘'\n\t}\n\telse if (south && east && !(north || west)) {\n\t\tedge = '┘'\n\t\tpipe = '┌'\n\t}\n\telse if (south && west && !(north || east)) {\n\t\tedge = '└'\n\t\tpipe = '┐'\n\t}\n\telse if (east && west && !(north || south)) {\n\t\tedge = '│'\n\t\tpipe = '─'\n\t}\n\n\t// one passage\n\telse if (north && !(south || east || west)) {\n\t\tedge = '┬'\n\t\tpipe = '╵'\n\t}\n\telse if (south && !(north || east || west)) {\n\t\tedge = '┴'\n\t\tpipe = '╷'\n\t}\n\telse if (east && !(north || south || west)) {\n\t\tedge = '┤'\n\t\tpipe = '╶'\n\t}\n\telse if (west && !(north || south || east)) {\n\t\tedge = '├'\n\t\tpipe = '╴'\n\t}\n\n\t// zero passages\n\telse if (!(north || south || east || west)) {\n\t\tedge = '┼'\n\t\tpipe = ' '\n\t}\n\n\tif (type === 'edge') {\n\t\treturn edge\n\t} else {\n\t\treturn pipe\n\t}\n}\n","import React, { useState } from 'react';\nimport './App.css';\nimport Maze from '../classes/maze'\nimport Graphic from '../classes/unicode-graphic'\n\nconst myMaze = new Maze([40,10])\nconst myGraphic = new Graphic(myMaze)\n\nconsole.log(myMaze)\n\nconst App = () => {\n\tconst [words, setWords] = useState(myGraphic.pipeMaze())\n\treturn (\n\t\t<>\n\t\t\t<h1>Maze Generator</h1>\n\t\t\t<p>\n\t\t\t\tGenerate your maze by clicking the button.\n\t\t\t</p>\n\t\t\t<input\n\t\t\t\ttype='button'\n\t\t\t\tonClick={() => {\n\t\t\t\t\tconst newMaze = new Maze([40,10])\n\t\t\t\t\tconst newGraphic = new Graphic(newMaze)\n\t\t\t\t\tsetWords(newGraphic.pipeMaze())\n\t\t\t\t}}\n\t\t\t\tvalue='Generate'\n\t\t\t/>\n\n\t\t\t<textarea\n\t\t\t\tclassName='results'\n\t\t\t\tvalue={words}\n\t\t\t\treadOnly={true}\n\t\t\t/>\n\t\t</>\n\t)\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n\twindow.location.hostname === 'localhost' ||\n\t\t// [::1] is the IPv6 localhost address.\n\t\twindow.location.hostname === '[::1]' ||\n\t\t// 127.0.0.0/8 are considered localhost for IPv4.\n\t\twindow.location.hostname.match(\n\t\t\t/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n\t\t)\n);\n\ntype Config = {\n\tonSuccess?: (registration: ServiceWorkerRegistration) => void;\n\tonUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(\n\t\t\tprocess.env.PUBLIC_URL,\n\t\t\twindow.location.href\n\t\t);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebook/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Let's check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl, config);\n\n\t\t\t\t// Add some additional logging to localhost, pointing developers to the\n\t\t\t\t// service worker/PWA documentation.\n\t\t\t\tnavigator.serviceWorker.ready.then(() => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t'This web app is being served cache-first by a service ' +\n\t\t\t\t\t\t\t'worker. To learn more, visit https://bit.ly/CRA-PWA'\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Is not localhost. Just register service worker\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then(registration => {\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tif (installingWorker == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the updated precached content has been fetched,\n\t\t\t\t\t\t\t// but the previous service worker will still serve the older\n\t\t\t\t\t\t\t// content until all client tabs are closed.\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t'New content is available and will be used when all ' +\n\t\t\t\t\t\t\t\t\t'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onUpdate) {\n\t\t\t\t\t\t\t\tconfig.onUpdate(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\tconsole.log('Content is cached for offline use.');\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onSuccess) {\n\t\t\t\t\t\t\t\tconfig.onSuccess(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch(error => {\n\t\t\tconsole.error('Error during service worker registration:', error);\n\t\t});\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl, {\n\t\theaders: { 'Service-Worker': 'script' }\n\t})\n\t\t.then(response => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tconst contentType = response.headers.get('content-type');\n\t\t\tif (\n\t\t\t\tresponse.status === 404 ||\n\t\t\t\t(contentType != null && contentType.indexOf('javascript') === -1)\n\t\t\t) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then(registration => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\t\tconsole.log(\n\t\t\t\t'No internet connection found. App is running in offline mode.'\n\t\t\t);\n\t\t});\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready\n\t\t\t.then(registration => {\n\t\t\t\tregistration.unregister();\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tconsole.error(error.message);\n\t\t\t});\n\t}\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}